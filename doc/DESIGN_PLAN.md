Design Plan
===

## Introduction
By writing this program, our team is tring to solve the problem of creating an environment in which users can create games as complety customizable as possible while simultaneously allowing for great flexibility in the type of authoring environment available. Furthermore, the complete game that is create in the authoring environment must be able to be saved and loaded to a player that knows exactly what to do with the data it is given to realize the game author's vision. All of the modules must refer to the game engine which serves as the rulebook for what is allowed to be created and played, and how those objects are to be created and initialized. 

The game that we chose was the scrolling platform style. This game is unique in that there should be a wide grid with game objects that appear at a specific postion on the grid. The screen should follow the main character(s) as it moves through the game to achieve its objective. Whether the screen moves at the speed of the character or at a previously determined speed is up to the user. 

Although we have a specific game type that we chose, the primary design goal of our project is to create a truly flexible experience, both for the users and for programmers that would wish to modify our programs for a different type of game. For this reason, all modules are attempting to develop interfaces that would be open to modification and extension. We are pursuing this goal by trying to preimptively consider all of the extensions and challenges that could be asked of us.

The high level design of our project requires that the game authoring environment keep track of all of the elements that have been added to a level's grid through lists that keep track of authored elements that have been added, removed, and modified. The GAE allows the user to add elements to a grid and to create custom elements to add to the grid. Then it stores the data which includes an identifier for each element and its position on the grid. The game is saved and data translates the objects to JSON. This JSON file will then be uploaded to the player which has all of the game engine back-end to run the game with correct behaviors for the authored elements. 

## Overview

![](https://imgur.com/qRwWk0g.jpg)

### Data
After a game is created (being made, not played), progress of item placement, settings toggling, and any other data will be saved on a periodic basis. GAE will create objects, and the flow will be:
Objects->JSON->Database
Database->JSON->Objects
The objects returned from JSON will be able to be used by GAE or Game Engine, allowing for a game to be edited, or played. The first flow, will include an .update() or .saveData() call from the GAEtoJSON or GEtoJSON interface methods which will take in the added, updated, and removed objects and then convert those to JSON that can be added, updated, or removed from the database. The second flow will include a call to JSONtoGAE.loadExisting(gameName) or JSONtoGE.loadExisting(gameName), which will search files (or a database, for extra feature) for a directory with the game name, and grab files from that directory to convert into levels with objects placed and attributes applied.

### Game Engine 
The Game Engine is essentially the backbone of any game that is created. It defines the classes for the objects and their rules for everything from the player character, to enemies, to in game objects, to weapons, projectiles, and power-ups. It must be flexible to allow for many types of platformers to be created within the same engine. For each game that is to be run, the engine is utilized to create all of the objects in the game along with their varying parameters. The engine also defines how to handle interactions between objects and handles them accordingly based on rules defined by the game creator.

### Game Player 
The Game Player acts as the conduit for which the user will play developed games, and will be developed as a Model-View Controller application. This stand alone application will be connected to the database of developed games ready to be played and also the game engine for actually running the game. The GameChooser will contain an observable list of developed games that the user can select from. Each developed game has an image, title, and description (as pictured in the user interface section). After selecting a game the GameView will be where the Game Engine module will be actually ran. Alongside the Game Engine view there will be a MenuBar and HeadsUpDisplay. The MenuBar will be the primary component for the controller, and the HeadsUpDisplay (accompanied with the Game Engine view) will be the the View that gets changed. 

### Game Authoring Environment 
The GAE is responsible for allowing the user to create custom authored elements that implement that interfaces defined by the game engine. Once a type of element is created, those attributes that correspond to the methods in the interface that it implements appear on a screen that the user can edit. Custom and default authored elements can be click and dragged onto a grid which is responsible for holding the position of each element to later be saved to game data. The GAE allows the user to save levels and games for playing and to load them for additional edits. The GAE is also responsible for allowing the user to define level flow and game transitions. 

## User Interface
### Game Player
![](https://i.imgur.com/dd5a084.jpg)
This is the screen that the user sees when they open the game player app. If the user has not yet created a game then they will be prompted to create one in the GAE.
![](https://i.imgur.com/KEcFFnT.jpg)
After the user selects a game to play they will move to screen two. This is where they play the game using the keys and mouse in the way specified in the GAE. They can also interact with the Game Player through the Game Player buttons in the menubar.

### Game Authoring Environment

<kbd>
  <img src="https://i.imgur.com/UV7DXG5.jpg">
</kbd>

This screen represents a preliminary version of the primary workspace of the Game Authoring Environment. First, a game is loaded or a new game is created. Within the game, the user may choose or create a stage to work on. Stages are organized in the interface in the bottom right corner. Here, the stage called "Level 2" is selected, so the map for the "level 2" stage is displayed in the large main panel with the grid, the map editiing area. Stages may be linked together, allowing the user to choose how a transition from one stage to another occurs, and organized within the panel as the user wishes. 

In the top right is the game element editor. There are many fundamental types of game elements, such as characters, enemies, weapons, projectiles, terrain blocks, etc. Each fundamental element type may represent many customizable elements whose properties, including images, behaviors, and parameters, may be selected by the user upon creation. In the game element editor, the drop-down menu allows the user to select an element type. All existing elements of that type are then displayed in the panel below. The user may also create a new element of the selected type, which would appear in the panel upon its creation. To add a game element to the stage, the user simply clicks its image in the panel and drags it to the desired spot in the stage editor's grid. An element may be multi-dimensional. Here, each of the example Minecraft blocks, which represent terrain blocks, are 1x1. However, the Pikachu sprite, which represents a player character, is 1x2, so its ear pokes into the next grid space above it. A stage or full game may be saved at any time by pressing the save buttons.

This example is far from complete; the area between the element and stage panels will likely be full of various buttons which have not yet been ironed out. The four headings at the top, which would each feature sub-menus, are also not finalized. Finally, every time the user creates a new game, game element, or stage, a unique pop-up menu (unique for every element type) featuring a vast array of cusomization options will appear, and the layout of these menus has not been designed, as the full scope of element types and parameters is not yet finalized. Despite these missing details, however, this picture should provide a very faithful representation of the core design and functionality of the finished product.

## Design Details

### Data
Our two modules will be the implementations of the two flows of information. These flows, as mentioned above, are Objects->JSON->Database and Database->JSON->Objects.
For the first flow, starting with Objects (items placed in game environment) being converted to JSON data and placed in a database, data will be able to be dynamically edited. Java objects will have Properties based on behavior in game, and Properties will be able to be dynamically added (new Property), its value changed, or removed from an object. GAE and Game Engine will both operate on the same objects, through different interfaces, allowing for the data-converting classes to call on the same objects to convert between data and game-editing and game-playing modes without having two sets of data that represent the same objects. Data files will be separated by level, and a game will be represented by a folder containing all of its setting and level files. This module can be extended to push to an online database like Firebase, and allow dynamic retrieval of data directly from the database instead of from a JSON file. This could lead to adding elements to a game at run-time, with data constantly pushing and pulling from a database. This module fits in with the goals of the project, because it allows for half of conversion between GAE and GE (GAE pushes data, GE pulls that data) and it also allows for saving progress in building or playing a game.
For the second flow, retrieving information on objects and their properties will satisfy the features in our game that will allow users to upload an existing game and then either edit that in the game authoring environment or play the game in the game player. The data retrieved from the database will consist of general game settings, individual game objects and their properties, and set up for different levels. Games will be read from their JSON data in the database and then games, levels, and game objects will be recreated in terms of the GAE and Game Engine objects so that a loaded game's settings and environment can be created. The database will pass JSON files for levels and game objects which whill then be parsed and converted in to a list of viable game objects. This module could later be extended to include features like online database retrieval. This module fits in with the goals of the project, because it provides the foundation for transferring a saved game from the first flow to a loaded game that the user can either play or continue to edit. 

### Game Authoring Environment
The main modules of the Game Authoring environment include the GameCreator, CreatorView, and AuthoredElement. 
The CreatorView will be the main interface used for the creation of a user interface for the game authoring environment. Currently, the CreatorView will be in charge of updating the Grid that displays the map that the user is currently designing the game on while the user adds new objects and features, and will open different editor windows based on the user's desired object. For example, a user will be able to edit levels directly through a Level editor, which will allow a user to create a new level, set a background for the level, and choose what actions can advance the user to the next level. The CreatorView will manage these windows, which will be implemented as smaller classes that are instatiated within the class implementing CreatorView.
The classes that implement the GameCreator will manage the basic aspects of the game itself, including save and load functions. The GameCreator classes will have dependencies on the Data interfaces necessary to save and load files to and from JSON. This GameCreator class will hold a list of Level objects as well as a list of AuthoredElement object that are in the current game. 
The AuthoredElement interface will be implemented by the GameObject classes in the GameEngine so that only the methods that need to be "seen" by the authoring environment will be available. Methods that are needed in the Game Player will be available to that component through another method implemented by the Game Object. 
These AuthoredElements will hold a list of Attributes, or different behaviors that can be selected by the user in the Game Authoring Environment. Because these behaviors will all implement this interface, each object will be able to hold as many different Attributes as the user would like to select -- for example, a powerup could both  give the player 20 points, give the player an extra life, and disappear after 10 seconds after the game begins. It will also be extendable -- developers will be able to easily add new behaviors that a game editor user could implement within their game by only needing to define a new subclass of Attributes.

### Game Engine
The Game Engine contains almost all of the logic behind a game to make it run. To that end, several interfaces will be used, with implementations specific to what type of logic is needed for a given selection. For example, there is a PlayerCharacter, Enemy, GameObject, Projectile, Weapon, and PowerUp interface for the player (or players), enemies, objects in the game like blocks or platforms, projectiles, weapons, and power ups. Within those classes are instances of other classes that implement interfaces such as Movement, which determines how they move (can they fly around, or are they subject to gravity and remain grounded unless they jump, for example), Behavior, which determines how they behave with respect to the player (will they follow the player, will they move in a straight line, will they move untill they reach a ledge, etc), and Interaction, which determines how they react to PlayerCharacters, Enemies, and/or GameObjects they make contact with (will they hurt the player, can enemies hurt each other, does the GameObject act as a slippery platform that forces PlayerCharacters and Enemies to slide forward, and so on). Since classes are created dynamically and internal behavior classes can be changed dynamically, a user can create enemies, objects, and so on with many different types of behaviors, and they can create other objects that can change, temporarily or permanently, how an object behaves whenever they interact with each other.

In regards to collaboration with other modules, the Game Engine classes are freely usable by the Data classes for instantiating objects in game. Parameters of all game objects can be set by the set methods of the game engine classes with string or numerical input and the engine uses reflection to instantiate the appropriate subclass for that parameter. For example if setMovementType() is called for an enemy with "flying" as an input, then an abstract class that defines movement that is extended by a flying subclass is instatiated via reflection that the enemy will now use to calculate its movements. The other modules, (PlayerCharacter, GameObject, Weapon, Projectile, Power-Up), all act in the same way for their interactions with the rest of the project. The game engine also will handle interactions between objects as defined by the user. When there is an interaction in the view, the controller relies on the game engine to figure out how to handle that interaction.

The game engine can be extended in many ways. Foremost, if any completely new type of specific in game object type is to be created, we can simply create a new interface for it in the same vein that we have created interfaces for the existing types. In all likelyhood though, the types we have already created will cover majority of possible additions, so it is more likely that we will be adding new features to existing object types. Our design allows us to do this by simply creating a subclass for a behavior type. For example, if we want enemies to be able to have a movement type of "hop" that wasn't previously defined, we can create a new MovementType subclass called "Hop" that can be instantiated via reflection in the same way the "Grounded" or "Flying" can be instantiated. Other than creating the class, all that needs to be done is for the GAE to add that as an option and send the engine the appropriate string to match it so it is instantiated properly via reflection. This same design pattern is found throughout the plan for the engine so extending any other portion of the engine should be similarly easy.

Engine is designed with two goals in mind: to allow for as flexible as possible a combination of many different possible objects and behavior, and to allow for the engine to be extensible enough to add more objects and behaviors without causing complications in other areas of code as much as possible. Both are the reason why we designed the code to make use of both Interfaces and implementations, to make any method call as generic as possible to avoid having to use logic and casts to determine what method calls are neccessary for what classes, and composition, to have behavior determined by stored classes rather than via inheritence structure. Designing the engine in this manner allows for a user to create a larger variety of objects in the game, it allows for someone to extend this variety with even more objects and behaviors, and it allows for dynamic creation of and use of these classes and their methods without needing to use complicated and messy logic to determine a class's identity. All of this falls within our overall design goal of making the program flexible enough to handle most extensions.

### Game Player 
The main function of the game player is to play the game and allow the user to interact with the game itself and the interface accompanied to the game. This structure inherently lends itself to a model view controller design pattern. The most notable part is that the game engine itself would represent the model. The two main sections of the Game Player are the initial screen for choosing a developed game to play (GameChooser) and then playing the actual game itself (GameView). In the GameChooser there will be a list of components each representing a single developed game. Each component (GameItem) will contain a title, image, and description. Selecting the game would in turn reach into the database retrieving all relevant information to play the game. The Game Player is not actually parsing this data. The parsing will only activate the relevant game data to create objects with the specific properties for the game chosen. It is then handed to the next component of the Game Player.

In the component which includes playing the actual game itself, there will be a few components that the user can interact with. There is the the MenuBar which will display all utilities that the user can choose from. This component will be developed using a shallow inheritance hierarchy most likely implemented such that the buttons order can be changed simply with an order change within the resource file - this may also be given as an option for the user to edit. Additionally, there will be a HUD component that will follow similar personlizable functionality. Lastly this component is where the model view controller will truly shine. The view as the gaming interface, the controller as the cross between the model and the view, and the model as the Game Engine. Interactions from the view will be passed to the controller to be processed, then received by Game Engine to be returned to the view. Additionally there will be a HeadsUpDisplay, containing DisplayComponent, which will display relevant information from the Game Engine to the user. This will be one component that will heavily rest on the functionality of the MVC pattern. 

## Example Games
General platformer game qualities:
* Provides players with the ability to control various characters that each have unique attributes that affect gameplay to some degree. Our game-building design will also allow for multiple playable characters
* Provides a story and "goal", a final level and boss that previous levels and mini-bosses lead up to. Our design will also allow game creators to create multiple levels of one game
    * Levels with increasing difficulty (our design will have level difficulty decided by how game-builder builds level and what items are placed in the level)
    * Allow user to upload cutscenes to increase plot-tiness?
* Provides stakes for players - lives and points. Our design will allow objects in the game to award extra lives when interacted with and for game-makers to decide what interactions should gain/lose a player points
* Benchmarks/save points - at certain points or after a level, progress is saved so that future mishaps don't completely reset players to a beginning state. Usually a player can respawn at a benchmark, without losing (all of their) points and sometimes retaining items.
* Item interaction - various items have special effects when itneracted with - enemies cause loss of health, powerups do things, some physical objects affect movement (springs allow extra-high jumping), some form of passageway lead to extra levels when interacted with, some things give coins/points

Game examples:
* Mario
    * Powerups: every 2D Mario platformer has a set of powerups that each do different things, some of which are game-specific and others of which are found across the series. The Super Mushroom, for example, increases the player's size and allows the player to break certain kinds of blocks, and when the player is hit by an enemy or projectile, they revert back to their previous form rather than losing a life. Our game should allow for many types of powerups that have different effects, or even multiple effects.
    * Jump Height: Most Mario games let the player influence the height of their jump and/or their airtime by holding down the jump button rather than just pushing it. This gives the player the ability to fine-tune their jumps to reach certain areas that a jump of a fixed height would not. Our program should allow for the game maker to decide if the player can influence their jump height or not.
    * Warp Zone: Super Mario Bros. (Nintendo, 1985) very famously featured a secret on many levels known as the Warp Zone, which, when found, would allow for the players to skip levels in the game entirely and appear further ahead in the game. Conversely, Super Mario Bros.: The Lost Levels (known as Super Mario Bros. 2 only in Japan) featured Warp Zones that sent the player backwards in the game, to previous levels, as a trap. Our program should allow for the game maker to design a game with the potential for dynamic progression through the game. 
* Sonic the Hedgehog (Sega, 1991) unique features:
    * speed-based/acceleration: our game-maker will have a physics engine to handle basic physics like gravity, but Sonic gameplay is built strongly on acceleration and inertia affecting movement (as opposed to a constant speed and movement stopping as soon as a key stops being pressed). Our physics engine should allow for acceleration and vector physics that should be able to be chosen over simple key press movement if desired.
    * losing rings: some interactions will lose the player points (rings) that have been collected over the course of gameplay. Sonic is unique in that lost coins are scattered around the area where they were lost, and can be regained within a certain amount of time. Our game should allow the ability for points to be regained if the game-maker wants this functionality (though probably not in this way, more like in Dark Souls, where all points are just dropped as one item, and can be regained if the player makes it back from respawn point to the item).
    * specific necessary item collection: Sonic has Chaos Emeralds, and a part of defeating Doctor Eggman is collecting emeralds. This provides goals in individual levels that affect final game outcome. Our game will have data that carries over between levels to support the ability to have actions in one level affect the overall game.
* Shovel Knight
    Shovel Knight is a much more modern 2D platformer released in 2014 by Yahct Club Games, and it brings some unique features to the table:
    * Environment destruction: The titular knight's shovel serves a dual purpose: it is both his primary weapon, and a tool which can be used to dig through parts of game's environment to explore and find treasure. In our authoring environment, the user should be able to select various properties for the elements they add, including things like interactions and breakability.
    * Multiple ways to attack: While the knight's primary attack is a swipe with his shovel, it is not his only attack. When the knight is airborn, the knight moves his shovel below him and attacks downward, as though riding a deadly pogo stick. Additionally, the knight is able to pick up and throw objects at enemies. Even more unique ways to attack can be purchased from shops. For example, a pair of gloves can be bought that can punch through terrain or punch enemies, which increases the knight's forward momentum. Another upgrade causes a spark to fly from the knight's shovel every time he swings, introducing a combination of melee and ranged attacks. In our game engine and authoring environment, we should try to accommodate as many styles and directions of attack as possible.
    * Currency system: Shovel Knight contains two areas, a village and an armor outpost, which contain NPC interactions and shops in which the knight can exchange the treasure he's accrued throughout the game for upgrades to his health, armor, and magic. This is very benefitial to the player's feelings of progression and payoff as the game progresses. As such, we should include ways to interact with NPCs and exchange a currency for useful items and upgrades.

## Design Considerations
* Game object implementing 2 interfaces (GAE and GE) to make data passing easier - only have to keep track of set of data instead of GAE data and GE data. Provides ability to optimize code length and speed, as data classes do not have to have separate files to convert between two types of objects with one set of data. Also adheres to MVC design, as the game objects, whether being added to a game or being played with, act as the model in MVC, and should be treated as a united model.
* Using JSON data files: One design decision that we discussed was whether to use JSON files or XML files. The pros of using XML files is that we had already worked with creating and reading XML files in the CellSociety project and that they would provide a good framework for adding properties to data representations of individual objects. The cons of using XML files is that it would be hard to locate specific instances of objects to change or remove as we are trying to do an auto-save type pass of data from the game authoring environemtn. The pros of using JSON files is that we had worked with them extensively in projects for Web Development and understood well how they were built and how the properties of different objects were set up. Additionally, JSON files will be easier to transfer into an online database when we try to do that as an extra feature and it will be easier to index different object representations using ID's so that removing and updating will be made more simple. The cons to JSON files is that they require a lot of parsing, because the files can become very long and have a lot of strings that must be converted into the appropriate data types. We decided on JSON mostly because we hope to move our data to an online database at some point and feel like JSON will allow for a more natural transition. 
* Saving data on disk before trying to move to an online database: We decided to first implement our database on our disk before trying to move our data into an online database, because we want to be able to focus on the design of our conversion from objects to JSON data first without having to worry about the other complications associated with moving the data to an online database. We do not want to have to sacrifice any good design in order to get the extra feature of an online database, so we hope to first implement the parsing of data well before moving onto the extension of moving this data to an off disk location.
* "Flow" design for data parsing: This separation of the data-saving process allows for more defined conversion of Java objects to database-readable JSON objects. By having the separation between GAE/GE and the database, we maintain a MVC design because the model (GAE and GE) never have to interact with actual data, just their own objects. It also allows for potential extension, adding a step in the flow or modifying data files directly (game cheats). The flow also allows for data-driven design of the project, where elements of the program can be dynamically added because of dynamic reading of data and property files, instead of having to edit hard-coded objects.
* The logistics of how to allow the user to set custom transitions between levels in the game authoring environment is a design consideration that the GAE had to make. One option was to have an authored element property that determined whether or not any of its behavior would end the level. With this implementation, every single authored element would need to have this customizable property, with only one or a few ultimately deciding the fate of level ending. The alernative was to have a level ending menu that in which the user could specify a level ending circumstance such as an achievement of a certain amount of points or the destruction of one or multiple characters. 
* The GAE had to consider how to deal with splash screens that the user could add to the beginning of a game, to the end of a game, or possibly between levels. It was decided that splash screens would be classified as specifc types of levels wherein the transition to the next level would be handled by a mouse input. We chose this as an alternative to the creation of a completely seperate game authoring object to handle splashscreens. 
* The creation of an Attributes superclass with subclasses that can be created to extend the GAEs ability to create custom authored elements was another design choice that was made to provide flexibility in the design. It was decided that treating specific behaviors as subsets of a broader category was the best way to leave our design open to extension.
* Using an MVC design pattern for creating the structure of the Game Player. The Game Player needs to be able to function nicely between adjusting the view (HeadsUpDisplay and the GameView) depending on user inputs (Key presses and inputs from the MenuBar) and sending information to the model and receiving information back. This MVC design pattern rests critically on the communication between the Game Player and Game Engine communication strength. Proper communication would result in successfully being able to play different side-scrolling games with different object behaviors, images, and physics applications. 
